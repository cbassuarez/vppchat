//
//  SourcesResolver.swift
//  VPPChat
//
//  Created by Sebastian Suarez-Solis on 12/19/25.
//


import Foundation

enum WebRetrievalPolicy: String, Codable, CaseIterable, Hashable {
  case auto
  case always
}

enum SourcesResolver {

  static func resolveSourcesPayload(
    _ sources: [VppSourceRef],
    webPolicy: WebRetrievalPolicy = .auto,
    githubToken: String? = nil,
    maxCharsPerSource: Int = 20_000,
    maxTotalChars: Int = 60_000
  ) async -> String {
    let ordered = sources.sortedByToken()
    guard !ordered.isEmpty else { return "" }

    var chunks: [String] = []
    var total = 0

    for s in ordered {
      if total >= maxTotalChars { break }

      let resolved: String = await resolveOne(
        s,
        webPolicy: webPolicy,
        githubToken: githubToken,
        maxChars: min(maxCharsPerSource, maxTotalChars - total)
      )

      if !resolved.isEmpty {
        chunks.append(resolved)
        total += resolved.count
      }
    }

    guard !chunks.isEmpty else { return "" }
    return """
Resolved source excerpts (generated by VPPChat; grounding only):
\(chunks.joined(separator: "\n\n"))
"""
  }

  // MARK: - One source

    private static func resolveOne(
        _ s: VppSourceRef,
        webPolicy: WebRetrievalPolicy,
        githubToken: String?,
        maxChars: Int
      ) async -> String {
    switch s.kind {
    case .file:
      return resolveFile(s, maxChars: maxChars)
    case .web:
        return await resolveWeb(s, webPolicy: webPolicy, maxChars: maxChars)
    case .repo:
        return await resolveRepo(s, webPolicy: webPolicy, githubToken: githubToken, maxChars: maxChars)
    case .ssh:
      return "" // intentionally no auto-resolution
    }
  }
    
    private static func dnsLooksResolvable(_ host: String) async -> Bool {
      await withCheckedContinuation { cont in
        DispatchQueue.global(qos: .utility).async {
          let cfHost = CFHostCreateWithName(nil, host as CFString).takeRetainedValue()
          CFHostStartInfoResolution(cfHost, .addresses, nil)
          var success: DarwinBoolean = false
          let addrs = CFHostGetAddressing(cfHost, &success)?.takeUnretainedValue() as NSArray?
          cont.resume(returning: success.boolValue && (addrs?.count ?? 0) > 0)
        }
      }
    }
 // MARK: Web Digest
    private static func extractFirst(_ html: String, pattern: String) -> String? {
      html.range(of: pattern, options: [.regularExpression]) .map { String(html[$0]) }
    }

    private static func extractMeta(_ html: String, name: String) -> String? {
      // matches: <meta name="description" content="...">
      let p = #"(?is)<meta\s+[^>]*name\s*=\s*["']\#(name)["'][^>]*content\s*=\s*["']([^"']+)["'][^>]*>"#
      guard let r = html.range(of: p, options: .regularExpression) else { return nil }
      let m = String(html[r])
      // capture content via a second regex (keeps it simple/robust enough)
      let cp = #"(?is)content\s*=\s*["']([^"']+)["']"#
      guard let cr = m.range(of: cp, options: .regularExpression) else { return nil }
      let cm = String(m[cr])
      return cm.replacingOccurrences(of: #"(?is)content\s*=\s*["']"#, with: "", options: .regularExpression)
               .replacingOccurrences(of: #"["']$"#, with: "", options: .regularExpression)
               .trimmingCharacters(in: .whitespacesAndNewlines)
    }

    private static func extractPropertyMeta(_ html: String, property: String) -> String? {
      let p = #"(?is)<meta\s+[^>]*property\s*=\s*["']\#(property)["'][^>]*content\s*=\s*["']([^"']+)["'][^>]*>"#
      guard let r = html.range(of: p, options: .regularExpression) else { return nil }
      let m = String(html[r])
      let cp = #"(?is)content\s*=\s*["']([^"']+)["']"#
      guard let cr = m.range(of: cp, options: .regularExpression) else { return nil }
      let cm = String(m[cr])
      return cm.replacingOccurrences(of: #"(?is)content\s*=\s*["']"#, with: "", options: .regularExpression)
               .replacingOccurrences(of: #"["']$"#, with: "", options: .regularExpression)
               .trimmingCharacters(in: .whitespacesAndNewlines)
    }

    private static func extractAssetLinks(_ html: String, baseURL: URL) -> (scripts: [URL], styles: [URL]) {
      func abs(_ s: String) -> URL? { URL(string: s, relativeTo: baseURL)?.absoluteURL }

      let scriptPattern = #"(?is)<script\s+[^>]*src\s*=\s*["']([^"']+)["'][^>]*>"#
      let stylePattern  = #"(?is)<link\s+[^>]*rel\s*=\s*["']stylesheet["'][^>]*href\s*=\s*["']([^"']+)["'][^>]*>"#

      func allMatches(_ pattern: String) -> [String] {
        guard let re = try? NSRegularExpression(pattern: pattern, options: []) else { return [] }
        let ns = html as NSString
        let matches = re.matches(in: html, range: NSRange(location: 0, length: ns.length))
        return matches.compactMap { m in
          guard m.numberOfRanges >= 2 else { return nil }
          return ns.substring(with: m.range(at: 1))
        }
      }

      let scripts = allMatches(scriptPattern).compactMap { abs($0) }
      let styles  = allMatches(stylePattern).compactMap { abs($0) }
      return (scripts, styles)
    }

    private static func headDigest(html: String, pageURL: URL) -> String {
      let title = extractHTMLTitle(html) ?? "(no <title>)"
      let desc  = extractMeta(html, name: "description") ?? "(no meta description)"
        let canonTag = extractFirst(html, pattern: #"(?is)<link\s+[^>]*rel\s*=\s*["']canonical["'][^>]*>"#)
        let canon = canonTag.flatMap { tag -> String? in
          let hp = #"(?is)href\s*=\s*["']([^"']+)["']"#
          return tag.range(of: hp, options: .regularExpression).map { String(tag[$0]) }
            .map { $0
              .replacingOccurrences(of: #"(?is)href\s*=\s*["']"#, with: "", options: .regularExpression)
              .replacingOccurrences(of: #"["']$"#, with: "", options: .regularExpression)
            }
        } ?? "(none)"

      let ogTitle = extractPropertyMeta(html, property: "og:title") ?? "(none)"
      let ogDesc  = extractPropertyMeta(html, property: "og:description") ?? "(none)"

      let assets = extractAssetLinks(html, baseURL: pageURL)
      let scriptList = assets.scripts.prefix(3).map { $0.absoluteString }.joined(separator: "\n- ")
      let styleList  = assets.styles.prefix(3).map { $0.absoluteString }.joined(separator: "\n- ")

      return """
    Head digest:
    - title: \(title)
    - description: \(desc)
    - canonical: \(canon)
    - og:title: \(ogTitle)
    - og:description: \(ogDesc)
    - scripts (top):\(assets.scripts.isEmpty ? " (none)" : "\n- \(scriptList)")
    - styles (top):\(assets.styles.isEmpty ? " (none)" : "\n- \(styleList)")
    """
    }

    
  // MARK: - FILE (security-scoped bookmark)

  private static func resolveFile(_ s: VppSourceRef, maxChars: Int) -> String {
    guard let bm = s.securityBookmark else { return "" }

    var isStale = false
    do {
      let url = try URL(
        resolvingBookmarkData: bm,
        options: [.withSecurityScope],
        relativeTo: nil,
        bookmarkDataIsStale: &isStale
      )

      guard url.startAccessingSecurityScopedResource() else { return "" }
      defer { url.stopAccessingSecurityScopedResource() }

      let data = try Data(contentsOf: url, options: [.mappedIfSafe])
      let text = String(decoding: data.prefix(maxChars), as: UTF8.self)

      let label = s.displayName ?? url.lastPathComponent
      return """
[\(s.id)] file · \(label)
```text
\(text)
```
"""
    } catch {
      return ""
    }
  }

  // MARK: - WEB (remote fetch)
    private static func extractHTMLTitle(_ html: String) -> String? {
      guard let r = html.range(of: "(?is)<title[^>]*>(.*?)</title>", options: .regularExpression) else { return nil }
      let m = String(html[r])
      return stripHTML(m)
    }

    private static func resolveWeb(_ s: VppSourceRef, webPolicy: WebRetrievalPolicy, maxChars: Int) async -> String {
      guard !s.ref.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return "" }
    guard let url = URL(string: s.ref) else { return "" }
      print("SRC web start id=\(s.id) ref=\(s.ref) url=\(url.absoluteString) host=\(url.host ?? "nil")")
    do {
      var req = URLRequest(url: url)
      req.httpMethod = "GET"
      req.timeoutInterval = 12
      req.setValue("text/html,text/plain;q=0.9,*/*;q=0.1", forHTTPHeaderField: "Accept")
        let (data, resp) = try await URLSession.shared.data(for: req)
        guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else { return "" }
        print("SRC web http id=\(s.id) status=\(http.statusCode) bytes=\(data.count)")
        print("SRC web headers id=\(s.id) headers=\(http.allHeaderFields)")
        // Prefer the final URL after redirects (if any)
        let finalURL = resp.url ?? url

        var rendered: RenderedPage? = nil
        if webPolicy == .always {
            rendered = await WebKitPageRenderer.shared.render(
              url: finalURL,
              timeout: 10,
              waitForSelector: "#root",
              minSelectorTextChars: 600,
              waitBudgetSeconds: 2.0,
              waitAfterReadyMs: 150,
              maxChars: min(maxChars / 2, 30_000)
            )
        }

        // Best-effort: only inject “text-ish” responses
        let ct = (http.value(forHTTPHeaderField: "Content-Type") ?? "").lowercased()
        guard ct.contains("text/") || ct.contains("application/xhtml") || ct.contains("application/xml") else { return "" }

        // Decode + strip
        let raw = String(decoding: data.prefix(maxChars * 2), as: UTF8.self)
        let digest = headDigest(html: raw, pageURL: url)
        print("SRC web raw id=\(s.id) chars=\(raw.count) head=\(raw.prefix(220))")
        let stripped = stripHTML(raw)
        print("SRC web stripped id=\(s.id) chars=\(stripped.count) head=\(stripped.prefix(220))")
        let title = extractHTMLTitle(raw) ?? "(no <title>)"
        
        // Optional deep fetch: first JS bundle
                let assets = extractAssetLinks(raw, baseURL: url)
                var jsSnippet = ""
                if webPolicy == .always, let first = assets.scripts.first {
                    print("SRC web js id=\(s.id) first=\(first.absoluteString)")

                  if let js = await fetchText(url: first, token: nil, maxChars: min(maxChars/2, 30_000)) {
                    jsSnippet = """
        JS bundle (clipped):
        ```js
        \(js)
        ```
        """
                  }
                }

        let renderedSection: String = {
          guard let rendered = rendered else { return "" }

          let clippedHTML = String(rendered.html.prefix(min(maxChars / 2, 30_000)))
          let clippedText = String(rendered.text.prefix(min(maxChars / 2, 30_000)))

          return """
        Rendered (WebKit) title: \(rendered.title)
        Rendered text (clipped):
        ```text
        \(clippedText)

        Rendered DOM (clipped):

        \(clippedHTML)

        """
        }()
                
        let finalText: String
        let format: String
        
        if stripped.trimmingCharacters(in: .whitespacesAndNewlines).count < 400,
           let rendered,
           !rendered.text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
          finalText = String(rendered.text.prefix(maxChars))
          format = "text"
        } else if stripped.trimmingCharacters(in: .whitespacesAndNewlines).count < 400 {
          finalText = String(raw.prefix(maxChars))
          format = "html"
        } else {
          finalText = String(stripped.prefix(maxChars))
          format = "text"
        }


        let label = s.displayName ?? url.host ?? s.ref
                return """
                [\(s.id)] web · \(label)
                \(digest)
                Title: \(title)
                
                ```\(format)
                \(finalText)
                ```
                    \(jsSnippet.isEmpty ? "" : "\n" + jsSnippet)
                    \(renderedSection.isEmpty ? "" : "\n" + renderedSection)
            """
    } catch {
      let ns = error as NSError
      print("SRC web error id=\(s.id) domain=\(ns.domain) code=\(ns.code) desc=\(ns.localizedDescription)")
      print("SRC web error userInfo id=\(s.id) \(ns.userInfo)")
      return ""
    }
  }

  // MARK: - REPO (remote GitHub fetch, minimal)

    private static func resolveRepo(_ s: VppSourceRef, webPolicy: WebRetrievalPolicy, githubToken: String?, maxChars: Int) async -> String {
        // Prefer structured repo ref
        let repoRef: RepoRef? = {
          if let r = s.repo { return r }
          return RepoRef.parseLoose(s.ref)
        }()
    
        let ownerRepo: (String, String)? = {
          if let r = repoRef { return (r.owner, r.name) }
          return parseGitHubOwnerRepo(from: s.ref)
        }()
    
        var ss = s
            ss.normalizeLegacyRepoIfNeeded()
            guard let rr = ss.repo else { return "" }
            let owner = rr.owner
            let repo  = rr.name

    // 1) default branch (best effort)
        let explicitBranch = repoRef?.branch?.trimmingCharacters(in: .whitespacesAndNewlines)
        let branch = (rr.branch?.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false)
              ? rr.branch!
             : (await fetchGitHubDefaultBranch(owner: owner, repo: repo, token: githubToken) ?? "main")
        
            let scopePathRaw = rr.path?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
            let scopePath = scopePathRaw.hasPrefix("/") ? String(scopePathRaw.dropFirst()) : scopePathRaw
            let scopeIsFile = scopePath.contains(".") && !scopePath.hasSuffix("/")


    // 2) README (raw)
        let readme = await fetchGitHubFileText(
              owner: owner,
              repo: repo,
              ref: branch,
              path: "README.md",
              token: githubToken,
              maxChars: maxChars / 2
            ) ?? ""

    // 3) root listing (GitHub contents API)
        let listingText: String
                if scopePath.isEmpty {
                  listingText = (await fetchGitHubRootListing(
                    owner: owner,
                    repo: repo,
                    token: githubToken,
                    maxChars: maxChars / 2
                  )) ?? ""
                } else if scopeIsFile {
                  listingText = ""
                } else if let entries = await fetchGitHubContentsEntries(
                  owner: owner,
                  repo: repo,
                  path: scopePath,
                  ref: branch,
                  token: githubToken
                ) {
                  listingText = entries
                    .sorted { $0.name.lowercased() < $1.name.lowercased() }
                    .map { "\($0.type == "dir" ? "dir " : "file")  \($0.name)" }
                    .joined(separator: "\n")
                } else {
                  listingText = ""
                }

// 4) Deep-resolution (ALWAYS): pull a few “shape of repo” files + a couple src files
    var deep: String = ""
    if webPolicy == .always {
      var parts: [String] = []
      var budget = min(maxChars / 2, 30_000)
      let perFile = min(8_000, max(1_000, budget / 4))

      func add(_ title: String, _ text: String) {
        guard !text.isEmpty else { return }
        parts.append("""
\(title)
```text
\(text)
```
""")
      }

        // Repo “hot paths” (grabs real logic first; safe if missing)
              let importantPaths: [String] = [
                "src/cli/index.js",
                "src/main.js",
                "src/boot.js",
                "src/work-model.js",
                "src/work-model.ts",
                "src/workModel.js",
                "src/types.d.ts",
                "ui/skins/console/main.js",
                "ui/skins/vite-breeze/main.js",
                "ui/skins/docs-reader/main.js",
                "ui/skins/cards-tabs/main.js",
                "ui/skins/kiosk/main.js",
              ]
        
              for p in importantPaths {
                if budget <= 0 { break }
                if let txt = await fetchGitHubFileText(owner: owner, repo: repo, ref: branch, path: p, token: githubToken, maxChars: min(perFile, budget)) {
                  add("File: \(p)", txt)
                  budget -= txt.count
                }
              }
        
      // Common top-level “signals”
      let commonTop: [String] = [
        "package.json",
        "pnpm-lock.yaml",
        "yarn.lock",
        "package-lock.json",
        "vite.config.ts",
        "vite.config.js",
        "tsconfig.json",
        "tailwind.config.js",
        "LICENSE"
      ]

      for path in commonTop {
        if budget <= 0 { break }
          if let txt = await fetchGitHubFileText(owner: owner, repo: repo, ref: branch, path: path, token: githubToken, maxChars: min(perFile, budget)) {
          add("File: \(path)", txt)
          budget -= txt.count
        }
      }

        // If a scope dir is set, prefer sampling from it; otherwise fall back to src/
              let sampleDir = scopePath.isEmpty ? "src" : (scopeIsFile ? "src" : scopePath)
              if budget > 0,
                 let src = await fetchGitHubContentsEntries(owner: owner, repo: repo, path: sampleDir, ref: branch, token: githubToken) {
        let candidates = src
          .filter { $0.type == "file" }
          .map(\.path)
          .filter { p in
            let lp = p.lowercased()
            return lp.hasSuffix(".ts") || lp.hasSuffix(".tsx") || lp.hasSuffix(".js") || lp.hasSuffix(".jsx") || lp.hasSuffix(".md") || lp.hasSuffix(".json")
          }
          .sorted()
          .prefix(6)

        for p in candidates {
          if budget <= 0 { break }
            if let txt = await fetchGitHubFileText(owner: owner, repo: repo, ref: branch, path: p, token: githubToken, maxChars: min(perFile, budget)) {
            add("File: \(p)", txt)
            budget -= txt.count
          }
        }
      }

      if !parts.isEmpty {
        deep = """

Deep excerpt (ALWAYS):
\(parts.joined(separator: "\n\n"))
"""
      }
    }


    let label = s.displayName ?? "\(owner)/\(repo)"
    let combined = """
README:
\(readme.isEmpty ? "(none)" : readme)

Root:
\(listingText.isEmpty ? "(none)" : listingText)
\(deep)
"""
    let clipped = combined.prefix(maxChars)

    return """
[\(s.id)] repo · \(label)
```text
\(clipped)
```
"""
  }
    
    private static func fetchGitHubListing(
        owner: String,
        repo: String,
        path: String?,
        ref: String,
        token: String?,
        maxChars: Int
      ) async -> String? {
        let p = (path?.isEmpty == false) ? "/\(path!)" : ""
        guard let url = URL(string: "https://api.github.com/repos/\(owner)/\(repo)/contents\(p)?ref=\(ref)") else { return nil }
    
        struct Entry: Decodable { let name: String; let type: String }
        do {
          var req = URLRequest(url: url)
          req.httpMethod = "GET"
          req.timeoutInterval = 12
          req.setValue("application/vnd.github+json", forHTTPHeaderField: "Accept")
          if let token, !token.isEmpty {
            req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
          }
          let (data, resp) = try await URLSession.shared.data(for: req)
          guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else { return nil }
          let items = try JSONDecoder().decode([Entry].self, from: data)
          let lines = items
            .sorted { $0.name.lowercased() < $1.name.lowercased() }
            .map { "\($0.type == "dir" ? "dir " : "file")  \($0.name)" }
            .joined(separator: "\n")
          return String(lines.prefix(maxChars))
        } catch {
          return nil
        }
      }



  // MARK: - Helpers

  private static func stripHTML(_ s: String) -> String {
    // cheap-ish: remove script/style blocks then tags
    var out = s
    out = out.replacingOccurrences(of: "(?is)<script.*?>.*?</script>", with: " ", options: .regularExpression)
    out = out.replacingOccurrences(of: "(?is)<style.*?>.*?</style>", with: " ", options: .regularExpression)
    out = out.replacingOccurrences(of: "(?is)<[^>]+>", with: " ", options: .regularExpression)
    out = out.replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
    return out.trimmingCharacters(in: .whitespacesAndNewlines)
  }

  private static func parseGitHubOwnerRepo(from ref: String) -> (String, String)? {
    // Accept:
    // - https://github.com/owner/repo
    // - owner/repo
    // - git@github.com:owner/repo.git
    let trimmed = ref.trimmingCharacters(in: .whitespacesAndNewlines)

    if trimmed.contains("github.com") {
      if trimmed.hasPrefix("git@") {
        // git@github.com:owner/repo(.git)
        let parts = trimmed.split(separator: ":")
        guard parts.count == 2 else { return nil }
        return parseOwnerRepoPath(String(parts[1]))
      } else if let url = URL(string: trimmed) {
        return parseOwnerRepoPath(url.path)
      }
    }

    return parseOwnerRepoPath(trimmed)
  }

  private static func parseOwnerRepoPath(_ pathLike: String) -> (String, String)? {
    var p = pathLike
    if p.hasPrefix("/") { p.removeFirst() }
    if p.hasSuffix(".git") { p = String(p.dropLast(4)) }
    let comps = p.split(separator: "/")
    guard comps.count >= 2 else { return nil }
    return (String(comps[0]), String(comps[1]))
  }

  private static func fetchText(url: URL?, token: String?, maxChars: Int) async -> String? {
    guard let url else { return nil }
      if let host = url.host {
        let ok = await dnsLooksResolvable(host)
        print("SRC dns host=\(host) resolvable=\(ok)")
      }
    do {
      var req = URLRequest(url: url)
      req.httpMethod = "GET"
      req.timeoutInterval = 12
      if let token, !token.isEmpty {
        req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
      }
      let (data, resp) = try await URLSession.shared.data(for: req)
      guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else { return nil }
      let raw = String(decoding: data, as: UTF8.self)
      return String(raw.prefix(maxChars))
    } catch {
      return nil
    }
  }

  private static func fetchGitHubDefaultBranch(owner: String, repo: String, token: String?) async -> String? {
    struct RepoInfo: Decodable { let default_branch: String }
    guard let url = URL(string: "https://api.github.com/repos/\(owner)/\(repo)") else { return nil }
    do {
      var req = URLRequest(url: url)
      req.httpMethod = "GET"
      req.timeoutInterval = 12
      req.setValue("application/vnd.github+json", forHTTPHeaderField: "Accept")
      if let token, !token.isEmpty {
        req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
      }
      let (data, resp) = try await URLSession.shared.data(for: req)
      guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else { return nil }
      return try JSONDecoder().decode(RepoInfo.self, from: data).default_branch
    } catch {
      return nil
    }
  }
    private struct GHContentEntry: Decodable {
        let name: String
        let type: String   // "file" | "dir"
        let path: String
      }
    
      private static func fetchGitHubContentsEntries(
        owner: String,
        repo: String,
        path: String,
        ref: String,
        token: String?
      ) async -> [GHContentEntry]? {
        var urlStr = "https://api.github.com/repos/\(owner)/\(repo)/contents"
        if !path.isEmpty {
          urlStr += "/\(path)"
        }
        urlStr += "?ref=\(ref)"
        guard let url = URL(string: urlStr) else { return nil }
    
        do {
          var req = URLRequest(url: url)
          req.httpMethod = "GET"
          req.timeoutInterval = 12
          req.setValue("application/vnd.github+json", forHTTPHeaderField: "Accept")
          if let token, !token.isEmpty {
            req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
          }
          let (data, resp) = try await URLSession.shared.data(for: req)
          guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else { return nil }
          return try JSONDecoder().decode([GHContentEntry].self, from: data)
        } catch {
          return nil
        }
      }
    
      private static func fetchGitHubRawFile(
        owner: String,
        repo: String,
        ref: String,
        path: String,
        token: String?,
        maxChars: Int
      ) async -> String? {
        let url = URL(string: "https://raw.githubusercontent.com/\(owner)/\(repo)/\(ref)/\(path)")
        return await fetchText(url: url, token: token, maxChars: maxChars)
      }
    // Prefer GitHub Contents API for deterministic reads (and future private repos).
      private struct GHFile: Decodable {
        let content: String?
        let encoding: String?
      }
    
      private static func fetchGitHubFileText(
        owner: String,
        repo: String,
        ref: String,
        path: String,
        token: String?,
        maxChars: Int
      ) async -> String? {
        let cleanPath = path.hasPrefix("/") ? String(path.dropFirst()) : path
        guard let url = URL(string: "https://api.github.com/repos/\(owner)/\(repo)/contents/\(cleanPath)?ref=\(ref)") else { return nil }
        do {
          var req = URLRequest(url: url)
          req.httpMethod = "GET"
          req.timeoutInterval = 12
          req.setValue("application/vnd.github+json", forHTTPHeaderField: "Accept")
          if let token, !token.isEmpty {
            req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
          }
          let (data, resp) = try await URLSession.shared.data(for: req)
          guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else { return nil }
          let decoded = try JSONDecoder().decode(GHFile.self, from: data)
          guard (decoded.encoding ?? "").lowercased() == "base64", let b64 = decoded.content else { return nil }
          let normalized = b64.replacingOccurrences(of: "\n", with: "")
          guard let bin = Data(base64Encoded: normalized) else { return nil }
          let text = String(decoding: bin, as: UTF8.self)
          return String(text.prefix(maxChars))
        } catch {
          return nil
        }
      }

  private static func fetchGitHubRootListing(owner: String, repo: String, token: String?, maxChars: Int) async -> String? {
    struct Entry: Decodable { let name: String; let type: String }
    guard let url = URL(string: "https://api.github.com/repos/\(owner)/\(repo)/contents") else { return nil }
    do {
      var req = URLRequest(url: url)
      req.httpMethod = "GET"
      req.timeoutInterval = 12
      req.setValue("application/vnd.github+json", forHTTPHeaderField: "Accept")
      if let token, !token.isEmpty {
        req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
      }
      let (data, resp) = try await URLSession.shared.data(for: req)
      guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else { return nil }
      let items = try JSONDecoder().decode([Entry].self, from: data)
      let lines = items
        .sorted { $0.name.lowercased() < $1.name.lowercased() }
        .map { "\($0.type == "dir" ? "dir " : "file")  \($0.name)" }
        .joined(separator: "\n")
      return String(lines.prefix(maxChars))
    } catch {
      return nil
    }
  }
}
