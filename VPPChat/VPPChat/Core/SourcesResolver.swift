//
//  SourcesResolver.swift
//  VPPChat
//
//  Created by Sebastian Suarez-Solis on 12/19/25.
//


import Foundation
import UniformTypeIdentifiers
#if canImport(PDFKit)
import PDFKit
#endif

enum WebRetrievalPolicy: String, Codable, CaseIterable, Hashable {
  case auto
  case always
}

enum SourcesResolver {

  static func resolveSourcesPayload(
    _ sources: [VppSourceRef],
    webPolicy: WebRetrievalPolicy = .auto,
    githubToken: String? = nil,
    maxCharsPerSource: Int = 20_000,
    maxTotalChars: Int = 60_000
  ) async -> String {
    let ordered = sources.sortedByToken()
    guard !ordered.isEmpty else { return "" }

    var chunks: [String] = []
    var total = 0
    let fileCount = ordered.filter { $0.kind == .file }.count
    let perFileCap: Int = {
      guard fileCount > 0 else { return maxCharsPerSource }
      let reserved = Double(maxTotalChars) * 0.8
      let perFile = Int(floor(reserved / Double(fileCount)))
      return min(maxCharsPerSource, max(1, perFile))
    }()

    for s in ordered {
      if total >= maxTotalChars { break }

      let perSourceCap = (s.kind == .file) ? perFileCap : maxCharsPerSource
      let resolved: String = await resolveOne(
        s,
        webPolicy: webPolicy,
        githubToken: githubToken,
        maxChars: min(perSourceCap, maxTotalChars - total)
      )

      if !resolved.isEmpty {
        chunks.append(resolved)
        total += resolved.count
      }
    }

    guard !chunks.isEmpty else { return "" }
    return """
Resolved source excerpts (generated by VPPChat; grounding only):
\(chunks.joined(separator: "\n\n"))
"""
  }

  // MARK: - One source

    private static func resolveOne(
        _ s: VppSourceRef,
        webPolicy: WebRetrievalPolicy,
        githubToken: String?,
        maxChars: Int
      ) async -> String {
    switch s.kind {
    case .file:
      return resolveFile(s, maxChars: maxChars)
    case .web:
        return await resolveWeb(s, webPolicy: webPolicy, maxChars: maxChars)
    case .repo:
        return await resolveRepo(s, webPolicy: webPolicy, githubToken: githubToken, maxChars: maxChars)
    case .ssh:
      return "" // intentionally no auto-resolution
    }
  }
    
    private static func dnsLooksResolvable(_ host: String) async -> Bool {
      await withCheckedContinuation { cont in
        DispatchQueue.global(qos: .utility).async {
          let cfHost = CFHostCreateWithName(nil, host as CFString).takeRetainedValue()
          CFHostStartInfoResolution(cfHost, .addresses, nil)
          var success: DarwinBoolean = false
          let addrs = CFHostGetAddressing(cfHost, &success)?.takeUnretainedValue() as NSArray?
          cont.resume(returning: success.boolValue && (addrs?.count ?? 0) > 0)
        }
      }
    }
 // MARK: Web Digest
    private static func extractFirst(_ html: String, pattern: String) -> String? {
      html.range(of: pattern, options: [.regularExpression]) .map { String(html[$0]) }
    }

    private static func extractMeta(_ html: String, name: String) -> String? {
      // matches: <meta name="description" content="...">
      let p = #"(?is)<meta\s+[^>]*name\s*=\s*["']\#(name)["'][^>]*content\s*=\s*["']([^"']+)["'][^>]*>"#
      guard let r = html.range(of: p, options: .regularExpression) else { return nil }
      let m = String(html[r])
      // capture content via a second regex (keeps it simple/robust enough)
      let cp = #"(?is)content\s*=\s*["']([^"']+)["']"#
      guard let cr = m.range(of: cp, options: .regularExpression) else { return nil }
      let cm = String(m[cr])
      return cm.replacingOccurrences(of: #"(?is)content\s*=\s*["']"#, with: "", options: .regularExpression)
               .replacingOccurrences(of: #"["']$"#, with: "", options: .regularExpression)
               .trimmingCharacters(in: .whitespacesAndNewlines)
    }

    private static func extractPropertyMeta(_ html: String, property: String) -> String? {
      let p = #"(?is)<meta\s+[^>]*property\s*=\s*["']\#(property)["'][^>]*content\s*=\s*["']([^"']+)["'][^>]*>"#
      guard let r = html.range(of: p, options: .regularExpression) else { return nil }
      let m = String(html[r])
      let cp = #"(?is)content\s*=\s*["']([^"']+)["']"#
      guard let cr = m.range(of: cp, options: .regularExpression) else { return nil }
      let cm = String(m[cr])
      return cm.replacingOccurrences(of: #"(?is)content\s*=\s*["']"#, with: "", options: .regularExpression)
               .replacingOccurrences(of: #"["']$"#, with: "", options: .regularExpression)
               .trimmingCharacters(in: .whitespacesAndNewlines)
    }

    private static func extractAssetLinks(_ html: String, baseURL: URL) -> (scripts: [URL], styles: [URL]) {
      func abs(_ s: String) -> URL? { URL(string: s, relativeTo: baseURL)?.absoluteURL }

      let scriptPattern = #"(?is)<script\s+[^>]*src\s*=\s*["']([^"']+)["'][^>]*>"#
      let stylePattern  = #"(?is)<link\s+[^>]*rel\s*=\s*["']stylesheet["'][^>]*href\s*=\s*["']([^"']+)["'][^>]*>"#

      func allMatches(_ pattern: String) -> [String] {
        guard let re = try? NSRegularExpression(pattern: pattern, options: []) else { return [] }
        let ns = html as NSString
        let matches = re.matches(in: html, range: NSRange(location: 0, length: ns.length))
        return matches.compactMap { m in
          guard m.numberOfRanges >= 2 else { return nil }
          return ns.substring(with: m.range(at: 1))
        }
      }

      let scripts = allMatches(scriptPattern).compactMap { abs($0) }
      let styles  = allMatches(stylePattern).compactMap { abs($0) }
      return (scripts, styles)
    }

    private static func headDigest(html: String, pageURL: URL) -> String {
      let title = extractHTMLTitle(html) ?? "(no <title>)"
      let desc  = extractMeta(html, name: "description") ?? "(no meta description)"
        let canonTag = extractFirst(html, pattern: #"(?is)<link\s+[^>]*rel\s*=\s*["']canonical["'][^>]*>"#)
        let canon = canonTag.flatMap { tag -> String? in
          let hp = #"(?is)href\s*=\s*["']([^"']+)["']"#
          return tag.range(of: hp, options: .regularExpression).map { String(tag[$0]) }
            .map { $0
              .replacingOccurrences(of: #"(?is)href\s*=\s*["']"#, with: "", options: .regularExpression)
              .replacingOccurrences(of: #"["']$"#, with: "", options: .regularExpression)
            }
        } ?? "(none)"

      let ogTitle = extractPropertyMeta(html, property: "og:title") ?? "(none)"
      let ogDesc  = extractPropertyMeta(html, property: "og:description") ?? "(none)"

      let assets = extractAssetLinks(html, baseURL: pageURL)
      let scriptList = assets.scripts.prefix(3).map { $0.absoluteString }.joined(separator: "\n- ")
      let styleList  = assets.styles.prefix(3).map { $0.absoluteString }.joined(separator: "\n- ")

      return """
    Head digest:
    - title: \(title)
    - description: \(desc)
    - canonical: \(canon)
    - og:title: \(ogTitle)
    - og:description: \(ogDesc)
    - scripts (top):\(assets.scripts.isEmpty ? " (none)" : "\n- \(scriptList)")
    - styles (top):\(assets.styles.isEmpty ? " (none)" : "\n- \(styleList)")
    """
    }

    
  // MARK: - FILE (security-scoped bookmark)

  private static func resolveFile(_ s: VppSourceRef, maxChars: Int) -> String {
    guard let bm = s.securityBookmark else {
      return fileSkipStub(source: s, reason: "Missing security-scoped bookmark.")
    }

    var isStale = false
    do {
      let url = try URL(
        resolvingBookmarkData: bm,
        options: [.withSecurityScope],
        relativeTo: nil,
        bookmarkDataIsStale: &isStale
      )

      guard url.startAccessingSecurityScopedResource() else {
        return fileSkipStub(source: s, reason: "Could not access security-scoped resource.")
      }
      defer { url.stopAccessingSecurityScopedResource() }

      let identity = try statFile(url: url)
      let extraction = try extractFileExcerpt(
        url: url,
        source: s,
        identity: identity,
        budget: maxChars
      )
      return extraction.excerptText
    } catch {
      return fileSkipStub(source: s, reason: "Extraction failed: \(error.localizedDescription)")
    }
  }

  static func statFile(url: URL) throws -> FileIdentity {
    let values = try url.resourceValues(forKeys: [
      .contentTypeKey,
      .fileSizeKey,
      .totalFileSizeKey,
      .contentModificationDateKey
    ])
    let byteSize = values.totalFileSize ?? values.fileSize
    return FileIdentity(
      displayName: url.lastPathComponent,
      ext: url.pathExtension.lowercased(),
      contentType: values.contentType?.identifier,
      byteSize: byteSize.map { Int64($0) },
      modifiedAt: values.contentModificationDate
    )
  }

  static func extractFileExcerpt(
    url: URL,
    source: VppSourceRef,
    identity: FileIdentity,
    budget: Int,
    progress: ((Double) -> Void)? = nil
  ) throws -> FileExtractionResult {
    let normalizedBudget = max(0, budget)
    let fileType = detectFileType(url: url, identity: identity)
    let label = source.displayName ?? identity.displayName

    switch fileType {
    case .text:
      let data = try readFileData(url: url, identity: identity, progress: progress)
      let text = String(decoding: data, as: UTF8.self)
      let (strategy, clipped) = clipHeadTail(text, budget: normalizedBudget)
      let header = excerptHeader(identity: identity, strategy: strategy, budget: normalizedBudget)
      let payload = """
[\(source.id)] file · \(label)
```text
\(header)

\(clipped)
```
"""
      return FileExtractionResult(
        excerptText: payload,
        strategy: strategy,
        charCount: payload.count,
        extractedAt: Date(),
        warning: nil
      )
    case .pdf:
      let pdfText = extractPDFText(url: url)
      if let pdfText, !pdfText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
        let (strategy, clipped) = clipHeadTail(pdfText, budget: normalizedBudget)
        let header = excerptHeader(identity: identity, strategy: strategy, budget: normalizedBudget)
        let payload = """
[\(source.id)] file · \(label)
```text
\(header)

\(clipped)
```
"""
        return FileExtractionResult(
          excerptText: payload,
          strategy: strategy,
          charCount: payload.count,
          extractedAt: Date(),
          warning: nil
        )
      }
      return metadataOnlyExcerpt(
        source: source,
        identity: identity,
        budget: normalizedBudget,
        warning: "PDF text extraction unavailable"
      )
    case .binary:
      return metadataOnlyExcerpt(
        source: source,
        identity: identity,
        budget: normalizedBudget,
        warning: nil
      )
    }
  }

  private enum DetectedFileType {
    case text
    case pdf
    case binary
  }

  private static func detectFileType(url: URL, identity: FileIdentity) -> DetectedFileType {
    let ext = identity.ext.lowercased()
    let textExtensions: Set<String> = [
      "txt", "md", "json", "yaml", "yml", "js", "ts", "tsx", "jsx", "swift", "py", "html", "css"
    ]
    if ext == "pdf" { return .pdf }

    if textExtensions.contains(ext) { return .text }

    if let type = UTType(identifier: identity.contentType ?? "") {
      if type.conforms(to: .pdf) { return .pdf }
      if type.conforms(to: .text) { return .text }
    }

    if let type = UTType(filenameExtension: ext), type.conforms(to: .text) {
      return .text
    }

    return .binary
  }

  private static func readFileData(
    url: URL,
    identity: FileIdentity,
    progress: ((Double) -> Void)? = nil
  ) throws -> Data {
    let handle = try FileHandle(forReadingFrom: url)
    defer { try? handle.close() }

    let chunkSize = 64 * 1024
    var data = Data()
    var bytesRead: Int64 = 0
    let totalBytes = identity.byteSize ?? 0

    while true {
      let chunk = try handle.read(upToCount: chunkSize) ?? Data()
      if chunk.isEmpty { break }
      data.append(chunk)
      bytesRead += Int64(chunk.count)
      if totalBytes > 0 {
        progress?(min(1.0, Double(bytesRead) / Double(totalBytes)))
      }
    }

    if totalBytes == 0 {
      progress?(1.0)
    }

    return data
  }

  private static func clipHeadTail(_ text: String, budget: Int) -> (ExcerptStrategy, String) {
    guard budget > 0 else { return (.headTail, "") }
    if text.count <= budget { return (.full, text) }
    let headCount = Int(Double(budget) * 0.7)
    let tailCount = max(0, budget - headCount)
    let head = String(text.prefix(headCount))
    let tail = String(text.suffix(tailCount))
    let omitted = max(0, text.count - headCount - tailCount)
    let divider = "\n--- OMITTED \(omitted) CHARS ---\n"
    return (.headTail, head + divider + tail)
  }

  private static func excerptHeader(identity: FileIdentity, strategy: ExcerptStrategy, budget: Int) -> String {
    let typeLabel = identity.contentType ?? (identity.ext.isEmpty ? "unknown" : ".\(identity.ext)")
    let sizeLabel = identity.byteSize.map { "\($0) bytes" } ?? "unknown"
    let modifiedLabel = identity.modifiedAt.map { iso8601String(from: $0) } ?? "unknown"
    return """
File: \(identity.displayName)
Type: \(typeLabel)
Size: \(sizeLabel)
Modified: \(modifiedLabel)
Strategy: \(strategy.rawValue)
Clipped to \(budget) chars
"""
  }

  private static func metadataOnlyExcerpt(
    source: VppSourceRef,
    identity: FileIdentity,
    budget: Int,
    warning: String?
  ) -> FileExtractionResult {
    let header = excerptHeader(identity: identity, strategy: .metadataOnly, budget: budget)
    let warningLine = warning.map { "Warning: \($0)\n" } ?? ""
    let metadataBlock = """
Metadata:
- name: \(identity.displayName)
- type: \(identity.contentType ?? (identity.ext.isEmpty ? "unknown" : ".\(identity.ext)"))
- size: \(identity.byteSize.map { "\($0) bytes" } ?? "unknown")
- modified: \(identity.modifiedAt.map { iso8601String(from: $0) } ?? "unknown")
"""
    let label = source.displayName ?? identity.displayName
    let payload = """
[\(source.id)] file · \(label)
```text
\(header)

\(warningLine)Not text; metadata only.
\(metadataBlock)
```
"""
    return FileExtractionResult(
      excerptText: payload,
      strategy: .metadataOnly,
      charCount: payload.count,
      extractedAt: Date(),
      warning: warning
    )
  }

  private static func extractPDFText(url: URL) -> String? {
#if canImport(PDFKit)
    return PDFDocument(url: url)?.string
#else
    return nil
#endif
  }

  private static func iso8601String(from date: Date) -> String {
    let formatter = ISO8601DateFormatter()
    formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
    return formatter.string(from: date)
  }

  private static func fileSkipStub(source: VppSourceRef, reason: String) -> String {
    let label = [source.displayName, source.ref]
      .compactMap { $0?.trimmingCharacters(in: .whitespacesAndNewlines) }
      .first { !$0.isEmpty } ?? "file"
    return """
[\(source.id)] file · \(label)
Skipped: \(reason)
"""
  }

  // MARK: - WEB (remote fetch)
    private static func extractHTMLTitle(_ html: String) -> String? {
      guard let r = html.range(of: "(?is)<title[^>]*>(.*?)</title>", options: .regularExpression) else { return nil }
      let m = String(html[r])
      return stripHTML(m)
    }

    private static func resolveWeb(_ s: VppSourceRef, webPolicy: WebRetrievalPolicy, maxChars: Int) async -> String {
      guard !s.ref.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return "" }
    guard let url = URL(string: s.ref) else { return "" }
      print("SRC web start id=\(s.id) ref=\(s.ref) url=\(url.absoluteString) host=\(url.host ?? "nil")")
    do {
      var req = URLRequest(url: url)
      req.httpMethod = "GET"
      req.timeoutInterval = 12
      req.setValue("text/html,text/plain;q=0.9,*/*;q=0.1", forHTTPHeaderField: "Accept")
        let (data, resp) = try await URLSession.shared.data(for: req)
        guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else { return "" }
        print("SRC web http id=\(s.id) status=\(http.statusCode) bytes=\(data.count)")
        print("SRC web headers id=\(s.id) headers=\(http.allHeaderFields)")
        // Prefer the final URL after redirects (if any)
        let finalURL = resp.url ?? url

        var rendered: RenderedPage? = nil
        if webPolicy == .always {
            rendered = await WebKitPageRenderer.shared.render(
              url: finalURL,
              timeout: 10,
              waitForSelector: "#root",
              minSelectorTextChars: 600,
              waitBudgetSeconds: 2.0,
              waitAfterReadyMs: 150,
              maxChars: min(maxChars / 2, 30_000)
            )
        }

        // Best-effort: only inject “text-ish” responses
        let ct = (http.value(forHTTPHeaderField: "Content-Type") ?? "").lowercased()
        guard ct.contains("text/") || ct.contains("application/xhtml") || ct.contains("application/xml") else { return "" }

        // Decode + strip
        let raw = String(decoding: data.prefix(maxChars * 2), as: UTF8.self)
        let digest = headDigest(html: raw, pageURL: url)
        print("SRC web raw id=\(s.id) chars=\(raw.count) head=\(raw.prefix(220))")
        let stripped = stripHTML(raw)
        print("SRC web stripped id=\(s.id) chars=\(stripped.count) head=\(stripped.prefix(220))")
        let title = extractHTMLTitle(raw) ?? "(no <title>)"
        
        // Optional deep fetch: first JS bundle
                let assets = extractAssetLinks(raw, baseURL: url)
                var jsSnippet = ""
                if webPolicy == .always, let first = assets.scripts.first {
                    print("SRC web js id=\(s.id) first=\(first.absoluteString)")

                  if let js = await fetchText(url: first, token: nil, maxChars: min(maxChars/2, 30_000)) {
                    jsSnippet = """
        JS bundle (clipped):
        ```js
        \(js)
        ```
        """
                  }
                }

        let renderedSection: String = {
          guard let rendered = rendered else { return "" }

          let clippedHTML = String(rendered.html.prefix(min(maxChars / 2, 30_000)))
          let clippedText = String(rendered.text.prefix(min(maxChars / 2, 30_000)))

          return """
        Rendered (WebKit) title: \(rendered.title)
        Rendered text (clipped):
        ```text
        \(clippedText)

        Rendered DOM (clipped):

        \(clippedHTML)

        """
        }()
                
        let finalText: String
        let format: String
        
        if stripped.trimmingCharacters(in: .whitespacesAndNewlines).count < 400,
           let rendered,
           !rendered.text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
          finalText = String(rendered.text.prefix(maxChars))
          format = "text"
        } else if stripped.trimmingCharacters(in: .whitespacesAndNewlines).count < 400 {
          finalText = String(raw.prefix(maxChars))
          format = "html"
        } else {
          finalText = String(stripped.prefix(maxChars))
          format = "text"
        }


        let label = s.displayName ?? url.host ?? s.ref
                return """
                [\(s.id)] web · \(label)
                \(digest)
                Title: \(title)
                
                ```\(format)
                \(finalText)
                ```
                    \(jsSnippet.isEmpty ? "" : "\n" + jsSnippet)
                    \(renderedSection.isEmpty ? "" : "\n" + renderedSection)
            """
    } catch {
      let ns = error as NSError
      print("SRC web error id=\(s.id) domain=\(ns.domain) code=\(ns.code) desc=\(ns.localizedDescription)")
      print("SRC web error userInfo id=\(s.id) \(ns.userInfo)")
      return ""
    }
  }

  // MARK: - REPO (remote GitHub fetch, minimal)

    private static func resolveRepo(_ s: VppSourceRef, webPolicy: WebRetrievalPolicy, githubToken: String?, maxChars: Int) async -> String {
        // Prefer structured repo ref
        let repoRef: RepoRef? = {
          if let r = s.repo { return r }
          return RepoRef.parseLoose(s.ref)
        }()
    
        let ownerRepo: (String, String)? = {
          if let r = repoRef { return (r.owner, r.name) }
          return parseGitHubOwnerRepo(from: s.ref)
        }()
    
        var ss = s
            ss.normalizeLegacyRepoIfNeeded()
            guard let rr = ss.repo else { return "" }
            let owner = rr.owner
            let repo  = rr.name

    // 1) default branch (best effort)
        let explicitBranch = repoRef?.branch?.trimmingCharacters(in: .whitespacesAndNewlines)
        let branch = (rr.branch?.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false)
              ? rr.branch!
             : (await fetchGitHubDefaultBranch(owner: owner, repo: repo, token: githubToken) ?? "main")
        
            let scopePathRaw = rr.path?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
            let scopePath = scopePathRaw.hasPrefix("/") ? String(scopePathRaw.dropFirst()) : scopePathRaw
            let scopeIsFile = scopePath.contains(".") && !scopePath.hasSuffix("/")


    // 2) README (raw)
        let readme = await fetchGitHubFileText(
              owner: owner,
              repo: repo,
              ref: branch,
              path: "README.md",
              token: githubToken,
              maxChars: maxChars / 2
            ) ?? ""

    // 3) root listing (GitHub contents API)
        let listingText: String
                if scopePath.isEmpty {
                  listingText = (await fetchGitHubRootListing(
                    owner: owner,
                    repo: repo,
                    token: githubToken,
                    maxChars: maxChars / 2
                  )) ?? ""
                } else if scopeIsFile {
                  listingText = ""
                } else if let entries = await fetchGitHubContentsEntries(
                  owner: owner,
                  repo: repo,
                  path: scopePath,
                  ref: branch,
                  token: githubToken
                ) {
                  listingText = entries
                    .sorted { $0.name.lowercased() < $1.name.lowercased() }
                    .map { "\($0.type == "dir" ? "dir " : "file")  \($0.name)" }
                    .joined(separator: "\n")
                } else {
                  listingText = ""
                }

// 4) Deep-resolution (ALWAYS): pull a few “shape of repo” files + a couple src files
    var deep: String = ""
    if webPolicy == .always {
      var parts: [String] = []
      var budget = min(maxChars / 2, 30_000)
      let perFile = min(8_000, max(1_000, budget / 4))

      func add(_ title: String, _ text: String) {
        guard !text.isEmpty else { return }
        parts.append("""
\(title)
```text
\(text)
```
""")
      }

        // Repo “hot paths” (grabs real logic first; safe if missing)
              let importantPaths: [String] = [
                "src/cli/index.js",
                "src/main.js",
                "src/boot.js",
                "src/work-model.js",
                "src/work-model.ts",
                "src/workModel.js",
                "src/types.d.ts",
                "ui/skins/console/main.js",
                "ui/skins/vite-breeze/main.js",
                "ui/skins/docs-reader/main.js",
                "ui/skins/cards-tabs/main.js",
                "ui/skins/kiosk/main.js",
              ]
        
              for p in importantPaths {
                if budget <= 0 { break }
                if let txt = await fetchGitHubFileText(owner: owner, repo: repo, ref: branch, path: p, token: githubToken, maxChars: min(perFile, budget)) {
                  add("File: \(p)", txt)
                  budget -= txt.count
                }
              }
        
      // Common top-level “signals”
      let commonTop: [String] = [
        "package.json",
        "pnpm-lock.yaml",
        "yarn.lock",
        "package-lock.json",
        "vite.config.ts",
        "vite.config.js",
        "tsconfig.json",
        "tailwind.config.js",
        "LICENSE"
      ]

      for path in commonTop {
        if budget <= 0 { break }
          if let txt = await fetchGitHubFileText(owner: owner, repo: repo, ref: branch, path: path, token: githubToken, maxChars: min(perFile, budget)) {
          add("File: \(path)", txt)
          budget -= txt.count
        }
      }

        // If a scope dir is set, prefer sampling from it; otherwise fall back to src/
              let sampleDir = scopePath.isEmpty ? "src" : (scopeIsFile ? "src" : scopePath)
              if budget > 0,
                 let src = await fetchGitHubContentsEntries(owner: owner, repo: repo, path: sampleDir, ref: branch, token: githubToken) {
        let candidates = src
          .filter { $0.type == "file" }
          .map(\.path)
          .filter { p in
            let lp = p.lowercased()
            return lp.hasSuffix(".ts") || lp.hasSuffix(".tsx") || lp.hasSuffix(".js") || lp.hasSuffix(".jsx") || lp.hasSuffix(".md") || lp.hasSuffix(".json")
          }
          .sorted()
          .prefix(6)

        for p in candidates {
          if budget <= 0 { break }
            if let txt = await fetchGitHubFileText(owner: owner, repo: repo, ref: branch, path: p, token: githubToken, maxChars: min(perFile, budget)) {
            add("File: \(p)", txt)
            budget -= txt.count
          }
        }
      }

      if !parts.isEmpty {
        deep = """

Deep excerpt (ALWAYS):
\(parts.joined(separator: "\n\n"))
"""
      }
    }


    let label = s.displayName ?? "\(owner)/\(repo)"
    let combined = """
README:
\(readme.isEmpty ? "(none)" : readme)

Root:
\(listingText.isEmpty ? "(none)" : listingText)
\(deep)
"""
    let clipped = combined.prefix(maxChars)

    return """
[\(s.id)] repo · \(label)
```text
\(clipped)
```
"""
  }
    
    private static func fetchGitHubListing(
        owner: String,
        repo: String,
        path: String?,
        ref: String,
        token: String?,
        maxChars: Int
      ) async -> String? {
        let p = (path?.isEmpty == false) ? "/\(path!)" : ""
        guard let url = URL(string: "https://api.github.com/repos/\(owner)/\(repo)/contents\(p)?ref=\(ref)") else { return nil }
    
        struct Entry: Decodable { let name: String; let type: String }
        do {
          var req = URLRequest(url: url)
          req.httpMethod = "GET"
          req.timeoutInterval = 12
          req.setValue("application/vnd.github+json", forHTTPHeaderField: "Accept")
          if let token, !token.isEmpty {
            req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
          }
          let (data, resp) = try await URLSession.shared.data(for: req)
          guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else { return nil }
          let items = try JSONDecoder().decode([Entry].self, from: data)
          let lines = items
            .sorted { $0.name.lowercased() < $1.name.lowercased() }
            .map { "\($0.type == "dir" ? "dir " : "file")  \($0.name)" }
            .joined(separator: "\n")
          return String(lines.prefix(maxChars))
        } catch {
          return nil
        }
      }



  // MARK: - Helpers

  private static func stripHTML(_ s: String) -> String {
    // cheap-ish: remove script/style blocks then tags
    var out = s
    out = out.replacingOccurrences(of: "(?is)<script.*?>.*?</script>", with: " ", options: .regularExpression)
    out = out.replacingOccurrences(of: "(?is)<style.*?>.*?</style>", with: " ", options: .regularExpression)
    out = out.replacingOccurrences(of: "(?is)<[^>]+>", with: " ", options: .regularExpression)
    out = out.replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
    return out.trimmingCharacters(in: .whitespacesAndNewlines)
  }

  private static func parseGitHubOwnerRepo(from ref: String) -> (String, String)? {
    // Accept:
    // - https://github.com/owner/repo
    // - owner/repo
    // - git@github.com:owner/repo.git
    let trimmed = ref.trimmingCharacters(in: .whitespacesAndNewlines)

    if trimmed.contains("github.com") {
      if trimmed.hasPrefix("git@") {
        // git@github.com:owner/repo(.git)
        let parts = trimmed.split(separator: ":")
        guard parts.count == 2 else { return nil }
        return parseOwnerRepoPath(String(parts[1]))
      } else if let url = URL(string: trimmed) {
        return parseOwnerRepoPath(url.path)
      }
    }

    return parseOwnerRepoPath(trimmed)
  }

  private static func parseOwnerRepoPath(_ pathLike: String) -> (String, String)? {
    var p = pathLike
    if p.hasPrefix("/") { p.removeFirst() }
    if p.hasSuffix(".git") { p = String(p.dropLast(4)) }
    let comps = p.split(separator: "/")
    guard comps.count >= 2 else { return nil }
    return (String(comps[0]), String(comps[1]))
  }

  private static func fetchText(url: URL?, token: String?, maxChars: Int) async -> String? {
    guard let url else { return nil }
      if let host = url.host {
        let ok = await dnsLooksResolvable(host)
        print("SRC dns host=\(host) resolvable=\(ok)")
      }
    do {
      var req = URLRequest(url: url)
      req.httpMethod = "GET"
      req.timeoutInterval = 12
      if let token, !token.isEmpty {
        req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
      }
      let (data, resp) = try await URLSession.shared.data(for: req)
      guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else { return nil }
      let raw = String(decoding: data, as: UTF8.self)
      return String(raw.prefix(maxChars))
    } catch {
      return nil
    }
  }

  private static func fetchGitHubDefaultBranch(owner: String, repo: String, token: String?) async -> String? {
    struct RepoInfo: Decodable { let default_branch: String }
    guard let url = URL(string: "https://api.github.com/repos/\(owner)/\(repo)") else { return nil }
    do {
      var req = URLRequest(url: url)
      req.httpMethod = "GET"
      req.timeoutInterval = 12
      req.setValue("application/vnd.github+json", forHTTPHeaderField: "Accept")
      if let token, !token.isEmpty {
        req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
      }
      let (data, resp) = try await URLSession.shared.data(for: req)
      guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else { return nil }
      return try JSONDecoder().decode(RepoInfo.self, from: data).default_branch
    } catch {
      return nil
    }
  }
    private struct GHContentEntry: Decodable {
        let name: String
        let type: String   // "file" | "dir"
        let path: String
      }
    
      private static func fetchGitHubContentsEntries(
        owner: String,
        repo: String,
        path: String,
        ref: String,
        token: String?
      ) async -> [GHContentEntry]? {
        var urlStr = "https://api.github.com/repos/\(owner)/\(repo)/contents"
        if !path.isEmpty {
          urlStr += "/\(path)"
        }
        urlStr += "?ref=\(ref)"
        guard let url = URL(string: urlStr) else { return nil }
    
        do {
          var req = URLRequest(url: url)
          req.httpMethod = "GET"
          req.timeoutInterval = 12
          req.setValue("application/vnd.github+json", forHTTPHeaderField: "Accept")
          if let token, !token.isEmpty {
            req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
          }
          let (data, resp) = try await URLSession.shared.data(for: req)
          guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else { return nil }
          return try JSONDecoder().decode([GHContentEntry].self, from: data)
        } catch {
          return nil
        }
      }
    
      private static func fetchGitHubRawFile(
        owner: String,
        repo: String,
        ref: String,
        path: String,
        token: String?,
        maxChars: Int
      ) async -> String? {
        let url = URL(string: "https://raw.githubusercontent.com/\(owner)/\(repo)/\(ref)/\(path)")
        return await fetchText(url: url, token: token, maxChars: maxChars)
      }
    // Prefer GitHub Contents API for deterministic reads (and future private repos).
      private struct GHFile: Decodable {
        let content: String?
        let encoding: String?
      }
    
      private static func fetchGitHubFileText(
        owner: String,
        repo: String,
        ref: String,
        path: String,
        token: String?,
        maxChars: Int
      ) async -> String? {
        let cleanPath = path.hasPrefix("/") ? String(path.dropFirst()) : path
        guard let url = URL(string: "https://api.github.com/repos/\(owner)/\(repo)/contents/\(cleanPath)?ref=\(ref)") else { return nil }
        do {
          var req = URLRequest(url: url)
          req.httpMethod = "GET"
          req.timeoutInterval = 12
          req.setValue("application/vnd.github+json", forHTTPHeaderField: "Accept")
          if let token, !token.isEmpty {
            req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
          }
          let (data, resp) = try await URLSession.shared.data(for: req)
          guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else { return nil }
          let decoded = try JSONDecoder().decode(GHFile.self, from: data)
          guard (decoded.encoding ?? "").lowercased() == "base64", let b64 = decoded.content else { return nil }
          let normalized = b64.replacingOccurrences(of: "\n", with: "")
          guard let bin = Data(base64Encoded: normalized) else { return nil }
          let text = String(decoding: bin, as: UTF8.self)
          return String(text.prefix(maxChars))
        } catch {
          return nil
        }
      }

  private static func fetchGitHubRootListing(owner: String, repo: String, token: String?, maxChars: Int) async -> String? {
    struct Entry: Decodable { let name: String; let type: String }
    guard let url = URL(string: "https://api.github.com/repos/\(owner)/\(repo)/contents") else { return nil }
    do {
      var req = URLRequest(url: url)
      req.httpMethod = "GET"
      req.timeoutInterval = 12
      req.setValue("application/vnd.github+json", forHTTPHeaderField: "Accept")
      if let token, !token.isEmpty {
        req.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
      }
      let (data, resp) = try await URLSession.shared.data(for: req)
      guard let http = resp as? HTTPURLResponse, (200..<300).contains(http.statusCode) else { return nil }
      let items = try JSONDecoder().decode([Entry].self, from: data)
      let lines = items
        .sorted { $0.name.lowercased() < $1.name.lowercased() }
        .map { "\($0.type == "dir" ? "dir " : "file")  \($0.name)" }
        .joined(separator: "\n")
      return String(lines.prefix(maxChars))
    } catch {
      return nil
    }
  }
}
